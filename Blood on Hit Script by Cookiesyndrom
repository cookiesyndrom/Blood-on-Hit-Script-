--//====================================================
--// BLOOD SYSTEM SCRIPT (Reworked for Readability & Style)
--//====================================================
--// Author: cookiesyndrom
--// Purpose: Creates realistic blood effects on NPCs and Players
--// Note: Structured and commented following Roblox Lua Style Guide as you guys told me.
--//====================================================

--//=============================
--// SERVICE REFERENCES
--//=============================
-- Using GetService ensures the same service instance is used consistently across scripts.
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

--//=============================
--// CONFIGURATION
--//=============================
local BLOOD_DELAY = 13.5      -- How long before blood fades
local BLOOD_PER_HIT = 5       -- Amount of blood decals created per hit

--//=============================
--// HELPER FUNCTIONS
--//=============================

--[[
	Determines if a given part belongs to a character (player or NPC).
	This is done by checking:
	- If the part is inside the "Npcs" folder.
	- If its parent chain contains a Humanoid.
	- If its name matches typical character body part names.
]]
local function isPartOfCharacter(part: BasePart): boolean
	-- Check if part belongs to the "Npcs" folder (which holds all NPCs)
	if part:IsDescendantOf(Workspace:FindFirstChild("Npcs") or game) then
		return true
	end

	-- Traverse up the ancestry tree to check for a Humanoid in parent hierarchy
	local parent = part.Parent
	while parent do
		if parent:FindFirstChildWhichIsA("Humanoid") then
			return true
		end
		if parent == Workspace then
			break
		end
		parent = parent.Parent
	end

	-- Convert name to lowercase to ensure matching is case-insensitive
	local name = part.Name:lower()

	-- Match against known character body part naming patterns
	if name:match("torso") or name:match("head") or name:match("arm") or
		name:match("leg") or name:match("humanoidrootpart") then
		return true
	end

	return false
end


--[[
	Casts multiple downward raycasts to find a solid ground surface under a given position.
	Skips over non-ground objects like characters or transparent parts.
]]
local function findGroundBelowPosition(origin: Vector3)
	-- Starting the ray slightly above the origin prevents it from instantly colliding with the body
	local startPosition = Vector3.new(origin.X, origin.Y + 20, origin.Z)

	-- Iterate multiple times downward to ensure we find actual ground
	for _ = 1, 50 do
		-- Create a RaycastParams each iteration (to ensure fresh context)
		local params = RaycastParams.new()
		local result = Workspace:Raycast(startPosition, Vector3.new(0, -1000, 0), params)

		-- If nothing was hit, stop the search
		if not result then
			return nil
		end

		local hitPart = result.Instance

		-- Validate that the hit part is a visible, collidable surface
		if hitPart.Transparency < 1 and hitPart.CanCollide then
			-- Ensure it's not a body part or existing blood decal
			if not isPartOfCharacter(hitPart) and not hitPart:IsDescendantOf(Workspace:FindFirstChild("BloodFolder") or game) then
				return result
			end
		end

		-- Move the next ray slightly below the previous hit point
		startPosition = result.Position + Vector3.new(0, -1, 0)
	end

	return nil
end


--[[
	Creates a large blood pool on the ground after a death event.
	This uses tweening for a smooth expansion and fading effect.
]]
local function createDeathBloodPool(origin: Vector3)
	local groundResult = findGroundBelowPosition(origin)
	if not groundResult then
		warn("No valid ground found for blood pool.")
		return
	end

	local groundPos = groundResult.Position

	-- Clone the base “Blood” part from the script for the new pool
	local pool = script:WaitForChild("Blood"):Clone()
	pool.Size = Vector3.new(9, 0.25, 7)
	pool.Position = Vector3.new(groundPos.X, groundPos.Y + 0.05, groundPos.Z)
	pool.Anchored = true
	pool.CanCollide = false
	pool.CanTouch = false
	pool.CanQuery = false
	pool.Transparency = 0
	pool.Parent = Workspace:WaitForChild("BloodFolder")

	-- Tween to shrink slightly to simulate liquid spreading
	local growTween = TweenService:Create(
		pool,
		TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
		{ Size = Vector3.new(7, 0.1, 7) }
	)
	growTween:Play()

	-- Delay fading process until the configured lifetime expires
	delay(BLOOD_DELAY, function()
		local fadeTween = TweenService:Create(
			pool,
			TweenInfo.new(2, Enum.EasingStyle.Linear),
			{ Transparency = 1 }
		)
		fadeTween:Play()

		-- Once fully faded, destroy the object to clean memory
		fadeTween.Completed:Connect(function()
			if pool and pool:IsDescendantOf(game) then
				pool:Destroy()
			end
		end)
	end)
end


--[[
	Helper function that fades out any given part smoothly using TweenService.
	After fading, the part is destroyed to free memory.
]]
local function fadeOutAndDestroy(part: BasePart, duration: number)
	if not (part and part:IsDescendantOf(game)) then
		return
	end

	local fadeTween = TweenService:Create(
		part,
		TweenInfo.new(duration, Enum.EasingStyle.Linear),
		{ Transparency = 1 }
	)
	fadeTween:Play()

	fadeTween.Completed:Connect(function()
		if part and part:IsDescendantOf(game) then
			part:Destroy()
		end
	end)
end


--[[
	Generates an individual blood drop part on the ground.
	Randomizes size and orientation for variation.
]]
local function createBloodDrop(position: Vector3): BasePart
	local clone = script:WaitForChild("Blood"):Clone()

	-- Randomize XZ scale for natural variation
	local size = math.random(13, 30) / 10
	clone.Size = Vector3.new(size, 0.13, size)
	clone.Position = position + Vector3.new(0, 0.01, 0)
	clone.Orientation = Vector3.new(0, math.random(0, 360), 0)

	-- Disable physics and collision for performance
	clone.Anchored = true
	clone.CanCollide = false
	clone.CanTouch = false
	clone.CanQuery = false
	clone.Transparency = 0
	clone.Parent = Workspace:WaitForChild("BloodFolder")

	return clone
end


--[[
	Spawns multiple blood drops around a character’s root part position.
	Handles both NPCs and players, accounting for their different intensities.
]]
local function spawnBloodDrops(rootPart: BasePart, isNPC: boolean)
	local totalDrops = isNPC and 1 or BLOOD_PER_HIT
	local playedSound = false

	for _ = 1, totalDrops do
		-- Random horizontal offset for spread
		local offset = Vector3.new(math.random(-20, 20) / 10, 0, math.random(-20, 20) / 10)
		local origin = rootPart.Position + offset

		local groundResult = findGroundBelowPosition(origin)
		if groundResult then
			local hitPosition = groundResult.Position
			local normal = groundResult.Normal

			-- Create and position the blood decal
			local drop = createBloodDrop(hitPosition)
			drop.Position = hitPosition + Vector3.new(0, drop.Size.Y / 2, 0)

			-- Rotate blood decal to align with the ground slope using axis-angle rotation
			if normal then
				local upVector = Vector3.new(0, 1, 0)
				local axis = upVector:Cross(normal)
				local angle = math.acos(upVector:Dot(normal))
				if axis.Magnitude > 0 and angle > 0 then
					drop.CFrame = CFrame.new(drop.Position) * CFrame.fromAxisAngle(axis.Unit, angle)
				end
			end

			-- Play sound effect once per emission cycle
			if not playedSound and drop:FindFirstChild("Sound") then
				drop.Sound:Play()
				playedSound = true
			end

			-- Delay fade to allow the drop to persist for a while
			delay(BLOOD_DELAY, function()
				fadeOutAndDestroy(drop, 1)
			end)
		end

		-- Slight wait between drops for realism and performance
		task.wait(math.random(5, 15) / 100)
	end
end


--[[
	Attaches event listeners to a humanoid so blood effects trigger upon damage or death.
]]
local function hookHumanoid(humanoid: Humanoid)
	-- Prevent multiple bindings to the same humanoid
	if humanoid:GetAttribute("BloodSystemHooked") then
		return
	end
	humanoid:SetAttribute("BloodSystemHooked", true)

	local character = humanoid.Parent
	if not character then return end

	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart then return end

	local oldHealth = humanoid.Health
	local isDead = false
	local player = Players:GetPlayerFromCharacter(character)
	local isNPC = not player

	-- Attach particle emitter system for active bleeding
	local attachment = rootPart:FindFirstChild("BloodAttachment") or script:WaitForChild("Attachment"):Clone()
	attachment.Name = "BloodAttachment"
	attachment.Parent = rootPart

	-- React to any changes in the humanoid's health
	humanoid.HealthChanged:Connect(function(newHealth)
		if isDead then return end

		-- Detect decrease in health (damage event)
		if newHealth < oldHealth then
			oldHealth = newHealth

			-- Emit configured number of blood particles from the attachment
			for _, emitter in ipairs(attachment:GetChildren()) do
				if emitter:IsA("ParticleEmitter") then
					emitter:Emit(emitter:GetAttribute("EmitCount") or emitter.Rate)
				end
			end

			spawnBloodDrops(rootPart, isNPC)

		-- Detect death event (health <= 0)
		elseif newHealth <= 0 then
			isDead = true
			local deathPosition = rootPart.Position

			-- Small delay to allow the character to settle before pooling blood
			task.wait(1.5)
			createDeathBloodPool(deathPosition)
		else
			oldHealth = newHealth
		end
	end)
end


--[[
	Scans all NPCs in the "Npcs" folder and attaches blood system to each.
]]
local function hookAllNPCsInFolder()
	local npcFolder = Workspace:WaitForChild("Npcs")

	for _, npc in ipairs(npcFolder:GetChildren()) do
		if npc:IsA("Model") then
			local humanoid = npc:FindFirstChildWhichIsA("Humanoid")
			if humanoid then
				hookHumanoid(humanoid)
			end
		end
	end
end


--[[
	Sets up monitoring for new NPCs being added dynamically to the Npcs folder.
]]
local function setupNPCMonitoring()
	local npcFolder = Workspace:WaitForChild("Npcs")

	-- Initial hookup for existing NPCs
	hookAllNPCsInFolder()

	-- Listen for any new NPC models being added
	npcFolder.ChildAdded:Connect(function(child)
		if child:IsA("Model") then
			task.wait(0.2)

			local humanoid = child:FindFirstChildWhichIsA("Humanoid")
			if humanoid then
				hookHumanoid(humanoid)
			else
				-- If humanoid isn’t present immediately, monitor for one
				local connection
				connection = child.ChildAdded:Connect(function(subChild)
					if subChild:IsA("Humanoid") then
						hookHumanoid(subChild)
						connection:Disconnect()
					end
				end)

				-- Disconnect the listener after 10 seconds to avoid leaks
				task.delay(10, function()
					if connection then
						connection:Disconnect()
					end
				end)
			end
		end
	end)
end


--//=============================
--// PLAYER CONNECTIONS
--//=============================

-- Attach blood system to all players currently in the game
for _, player in ipairs(Players:GetPlayers()) do
	if player.Character then
		local humanoid = player.Character:FindFirstChildWhichIsA("Humanoid")
		if humanoid then
			hookHumanoid(humanoid)
		end
	end
end

-- Connect to PlayerAdded event for future players
Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		local humanoid = character:WaitForChild("Humanoid", 5)
		if humanoid then
			hookHumanoid(humanoid)
		end
	end)
end)

-- Start NPC monitoring system
setupNPCMonitoring()
